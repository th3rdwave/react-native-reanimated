"use strict";(self.webpackChunkreact_native_reanimated=self.webpackChunkreact_native_reanimated||[]).push([[1683],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return p}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,m=u(e,["components","mdxType","originalType","parentName"]),d=l(n),p=i,y=d["".concat(s,".").concat(p)]||d[p]||c[p]||o;return n?a.createElement(y,r(r({ref:t},m),{},{components:n})):a.createElement(y,r({ref:t},m))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var u={};for(var s in t)hasOwnProperty.call(t,s)&&(u[s]=t[s]);u.originalType=e,u.mdxType="string"==typeof e?e:i,r[1]=u;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7477:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return u},metadata:function(){return s},toc:function(){return l},default:function(){return c}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r={id:"animatedLayout",title:"<AnimatedLayout>",sidebar_label:"<AnimatedLayout>"},u=void 0,s={unversionedId:"api/LayoutAnimations/animatedLayout",id:"api/LayoutAnimations/animatedLayout",isDocsHomePage:!1,title:"<AnimatedLayout>",description:"The AnimatedLayout component is responsible for observing changes in its subtree AnimatedLayout. You can treat it as a View component because it takes the same set of properties. The component is essential for entering and exiting animations as well as layout transitions and each animated component that wants to make use of any layout animation has to be placed under an AnimatedLayout component. There are two important notes about this component that you should keep in mind:",source:"@site/docs/api/LayoutAnimations/AnimatedLayout.md",sourceDirName:"api/LayoutAnimations",slug:"/api/LayoutAnimations/animatedLayout",permalink:"/react-native-reanimated/docs/next/api/LayoutAnimations/animatedLayout",version:"current",frontMatter:{id:"animatedLayout",title:"<AnimatedLayout>",sidebar_label:"<AnimatedLayout>"},sidebar:"docs",previous:{title:"scrollTo",permalink:"/react-native-reanimated/docs/next/api/nativeMethods/scrollTo"},next:{title:"Custom Animations",permalink:"/react-native-reanimated/docs/next/api/LayoutAnimations/customAnimations"}},l=[{value:"Example",id:"example",children:[]}],m={toc:l};function c(e){var t=e.components,n=(0,i.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AnimatedLayout")," component is responsible for observing changes in its subtree ",(0,o.kt)("inlineCode",{parentName:"p"},"AnimatedLayout"),". You can treat it as a ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," component because it takes the same set of properties. The component is essential for entering and exiting animations as well as layout transitions and each animated component that wants to make use of any layout animation has to be placed under an ",(0,o.kt)("inlineCode",{parentName:"p"},"AnimatedLayout")," component. There are two important notes about this component that you should keep in mind: "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"It will manage all its descendants' animations even if it's mounting and unmounting by itself."),(0,o.kt)("li",{parentName:"ul"},"There is no need to nest one ",(0,o.kt)("inlineCode",{parentName:"li"},"AnimatedLayout")," in another one because the higher one would already watch the subtree of the lower one. ")),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"You can use ",(0,o.kt)("inlineCode",{parentName:"p"},"AnimatedLayout")," as regular React component and his children can use by transitions and mounting/unmounting animations."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"    import { AnimatedLayout } from 'react-native-reanimated';\n    \n    function CustomFunctionComponent() {\n\n        return (\n            <AnimatedLayout>\n                // watched subtree\n            </AnimatedLayout>\n        );\n    }\n")),(0,o.kt)("p",null,"More advanced example with SWM's logo"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"    import { \n        AnimatedLayout,\n        SlideInRight,\n        SlideOutLeft,\n        SlideInDown,\n        SlideOutUp,\n        SlideInLeft,\n        SlideOutRight,\n        OpacityIn,\n        OpacityOut,\n    } from 'react-native-reanimated';\n    \n    const AnimatedText = Animated.createAnimatedComponent(Text);\n    \u200b\n    function SWMLogo() {\n    \u200b\n        return (\n            <AnimatedLayout>\n                <Animated.View \n                    entering={SlideInRight.delay(300)} \n                    exiting={SlideOutLeft.delay(300)} \n                    style={styles.left} \n                />\n                <Animated.View \n                    entering={SlideInDown} \n                    exiting={SlideOutUp} \n                    style={styles.top} \n                />\n                <Animated.View \n                    entering={SlideInLeft} \n                    exiting={SlideOutRight} \n                    style={styles.animatedView} \n                >\n                    <AnimatedText \n                        entering={OpacityIn.delay(600).duration(3000)} \n                        exiting={OpacityOut.duration(3000)}\n                    > \n                        SWM \n                    </AnimatedText>\n                </Animated.View>\n            </AnimatedLayout>\n        );\n    }\n")),(0,o.kt)("p",null,"See results:"),(0,o.kt)("video",{src:"https://user-images.githubusercontent.com/36106620/120326638-39ee0200-c2e9-11eb-8dca-3f3b999c5017.mov",controls:"controls",muted:"muted"}))}c.isMDXComponent=!0}}]);